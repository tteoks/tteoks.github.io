<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Jinho Yu</title>
        <link>https://tteoks.github.io/post/</link>
        <description>Recent content in Posts on Jinho Yu</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>COPYRIGHT (C) JINHO,YU. ALL RIGHTS RESERVED.</copyright>
        <lastBuildDate>Sun, 11 Feb 2024 14:24:19 +0900</lastBuildDate><atom:link href="https://tteoks.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[알고리즘] Sort 알고리즘</title>
        <link>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sort-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
        <pubDate>Sun, 11 Feb 2024 14:24:19 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sort-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</guid>
        <description>&lt;h1 id=&#34;정렬&#34;&gt;정렬&lt;/h1&gt;
&lt;p&gt;주어진 데이터를 일정한 순서로 재배열하는 알고리즘으로 이러한 재배열을 통해 검색, 비교, 출력등의 작업을 효율적으로 수행할 수 있음&lt;/p&gt;
&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;인접한 두 원소의 대소를 비교하여 순서가 잘못된 경우, 서로 교환하는 정렬 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열의 처음부터 끝까지 반복하여 인접한 두 원소의 대소를 비교해 정렬을 수행함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구현이 간단하고, 코드 이해가 쉬웁&lt;/li&gt;
&lt;li&gt;소규모 데이터 정렬에 간단하게 사용하기 용이&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;다른 정렬 알고리즘에 비해 비효율적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터가 이미 거의 정렬되어 있는 경우&lt;/li&gt;
&lt;li&gt;정렬할 데이터의 크기가 작을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;삽입-정렬-insert-sort&#34;&gt;삽입 정렬 (Insert Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;두번째 Index부터 시작해 이전 index 원소들과 비교하여 적절한 위치에 삽입하면서 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;크기가 적은 데이터나, 대부분의 데이터가 이미 정렬된 경우 효과적&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;데이터 양이 많거나, 정렬된 상태가 아닐 떄 효율성이 떨어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2) / O(n)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작은 데이터 세트를 정렬할 때 사용&lt;/li&gt;
&lt;li&gt;다른 정렬 알고리즘의 전처리 단계로 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선택-정렬-select-sort&#34;&gt;선택 정렬 (Select Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열에서 최소값(또는 최대값)을 선택하여 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아래 프로세스 반복 (n: {1 ~ n})&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n번째로 작은 데이터를 찾아 n번째 위치와 교환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;비교 횟수가 고정되어 있어, 어떤 데이터가 어떤 순서로 정렬되어 있던 비교횟수가 동일함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;불안정 정렬이며, 같은 값의 순서 보장 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 셋의 크기가 작은 상황에서 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;분할 정복 알고리즘을 기반으로 정렬하는 알고리즘으로, 기준점(pivot)을 기준으로 작은값은 왼쪽, 큰값은 오른쪽에 위치시키며 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pivot을 선택하고, pivot을 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 위치시키며 정렬 수행&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;평균적으로 매우 빠른 속도를 가지며, 분할 과정에서 추가적인 메모리가 필요하지 않음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;매우 효율적으로 정렬을 수행함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;선택된 pivot에 따라 성능이 불규칙함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn) ~ O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(logn)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 상황에서 효율적으로 사용 가능&lt;/li&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;분할 정복 알고리즘을 사용하여 정렬하는 방식으로, 배열을 반으로 나누고 각 부분을 정렬한 후 병합하는 방식으로 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열을 반으로 나누어 정렬된 부분 배열을 만든 후, 병합하여 전체 배열 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;안정적인 정렬 방식이며, 재귀적인 방식으로 구현 가능&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;평균적으로 매우 빠른 속도를 가짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;힙(Heap) 자료구조를 이용하여 정렬하는 방식으로, 힙을 구성하고 최대 힙 또느 최소 힙을 유지하면서 졍렬을 수행하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;초기에 배열을 힙으로 구성한 후, 최상단 노드를 삭제하며 정렬 수행&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;완전 이진 트리 구조를 사용하여 효율적으로 수현하며 추가적인 메모리를 사용하지 않음&lt;/p&gt;
&lt;p&gt;최대/최소 힙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대 힙: 부모노드가 항상 자식 노드보다 큼 -&amp;gt; 내림차순 정렬&lt;/li&gt;
&lt;li&gt;최소 힙: 부모노드가 항상 자식 노드보다 작음 -&amp;gt; 오름차순 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;매우 효율적으로 정렬 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;안정적인 정렬 방식이 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;li&gt;우선순위 큐 구현&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;셸-정렬-shell-sort&#34;&gt;셸 정렬 (Shell Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;삽입 정렬을 개선한 알고리즘으로, 배열을 일정한 간격으로 나누어 부분 리스트를 만들고, 각각의 부분 리스트를 삽입 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;일정한 간격(초기값: 전체 배열 길이의 반)을 설정하여 부분 리스트를 생성하고, 해당 부분 리스트를 삽입 정렬을 통해 정렬하며 간격을 줄여가면서 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;간격에 따라 성능이 크게 달라질 수 있지만, 추가적인 메모리를 사용하지 않음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;평균적으로 삽입 정렬보다 빠름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;최적의 간격을 찾기 어려운 경우도 존재함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn) ~ O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬 시, 삽입 정렬보다 빠른 알고리즘이 필요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기수-정렬-radix-sort&#34;&gt;기수 정렬 (Radix Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자릿수를 기준으로 정렬하는 알고리즘으로 LSD (가장 작은 자리수) 또는 MSD (가장 높은 수) 방식을 통해 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식 (LSD)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;가장 낮은 자리수부터 시작하여 정렬을 수행, 각 자리수별로 정렬
(일의 자리부터 시작해, 가장 높은 자리까지 정렬)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;안정적인 정렬 알고리즘이지만, 데이터 자리수가 큰 경우 공간 복잡도가 커질 수 있음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;안정적인 정렬 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;일부 자리수가 없는 경우 사용 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(d*(n+k)) (d: 최대 자리수, k: 각 자리수 범위)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n + k): (k: 각 자리수 볌위)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 자리수를 기준으로 정렬 (ex. 정수, 문자열)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;안정-정렬-vs-불안정-정렬&#34;&gt;안정 정렬 vs 불안정 정렬&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;안정 정렬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 값이 입력 순서와 동일하게 정렬되는 알고리즘의 특성&lt;/li&gt;
&lt;li&gt;ex) 삽입 정렬, 벙합 정렬, 버블 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불안정 정렬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 값이 이력 순서와 동일하지 않게 정렬되는 알고리즘의 특성&lt;/li&gt;
&lt;li&gt;ex) 쿽 정렬, 선택 정렬, 계수 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[자료구조] Deque 개념 정리</title>
        <link>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-deque-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</link>
        <pubDate>Wed, 31 Jan 2024 14:23:51 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-deque-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</guid>
        <description>&lt;h3 id=&#34;덱-deque의-개념&#34;&gt;덱 (Deque)의 개념&lt;/h3&gt;
&lt;p&gt;Deque은 양쪽 끝에서 데이터의 삽입과 삭제가 가능한 선형자료구조로, Double-Ended Queue의 약자이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tteoks.github.io/img/cs_deque.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DeQue&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Deque는 양쪽 끝에서 삽입과 삭제가 이루어질 수 있음&lt;/li&gt;
&lt;li&gt;동적으로 자료구조의 크기를 조절 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-연산&#34;&gt;주요 연산&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AddFront 연산: Deque의 앞에 데이터를 추가&lt;/li&gt;
&lt;li&gt;AddRear 연산: Deque의 뒤에 데이터를 추가&lt;/li&gt;
&lt;li&gt;RemoveFront 연산: Deque의 앞의 데이터를 삭제&lt;/li&gt;
&lt;li&gt;RemoveRear 연산: Deque의 뒤의 데이터를 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;양쪽 끝에서 효율적으로 삽입과 삭제를 O(1)에 수행할 수 있음&lt;/li&gt;
&lt;li&gt;Queue와 Stack의 특성을 모두 가지고 있어 다양한 상황에서 활용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배열 기반 구현의 경우, 메모리를 일정하게 할당해야 해서 낭비 발생 가능&lt;/li&gt;
&lt;li&gt;양쪽 끝에서 연산을 모두 지원하므로, 구현이 복잡할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복잡도&#34;&gt;복잡도&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;앞/뒤 삽입: O(1)&lt;/li&gt;
&lt;li&gt;앞/뒤 삭제: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;활용&#34;&gt;활용&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스크롤링 목록&lt;br&gt;
사용자가 스크롤을 하면서 앞과 뒤에서 아이템을 추가하고 삭제할 때 사용&lt;/li&gt;
&lt;li&gt;이중 종료 조건의 큐(Queue)&lt;br&gt;
양쪽에서 삽입과 삭제를 할 수 있는 특성을 이용하여 다양한 큐 구조를 구현&lt;/li&gt;
&lt;li&gt;회문(Palindrome) 검사&lt;br&gt;
앞뒤에서 데이터를 비교하여 회문 여부를 확인할 때 활용&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[자료구조] Linked List 개념 정리</title>
        <link>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-linked-list-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</link>
        <pubDate>Wed, 17 Jan 2024 14:02:48 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-linked-list-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</guid>
        <description>&lt;h1 id=&#34;연결-리스트-linked-list&#34;&gt;연결 리스트 (Linked List)&lt;/h1&gt;
&lt;p&gt;추상적 자료형인 리스트를 구현한 자료구조로, 데이터 덩어리 (이하 Node)들이 연결된 선형 자료구조이다. 각 노드는 데이터와 다음 노드를 가리키는 링크 (포이터)로 이루어져 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tteoks.github.io/img/cs_linked-list.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Linked List&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;본 포스팅은 Singly linked list를 기반으로 설명한다.&lt;/p&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;연속되는 항목들이 포인터로 연결되어 있음&lt;/li&gt;
&lt;li&gt;데이터의 크기 제한이 없음 (데이터 추가/삭제 쉬움)&lt;/li&gt;
&lt;li&gt;데이터를 탐색할 때 순차적으로 접근해야 함&lt;/li&gt;
&lt;li&gt;메모리를 필요한 만큼만 사용하지만, 포인터로 인한 추가 메모리 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-함수&#34;&gt;주요 함수&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;add: List 끝에 데이터 삽입&lt;/li&gt;
&lt;li&gt;insert: N번째 위치에 데이터삽입&lt;/li&gt;
&lt;li&gt;delete: List 끝에 데이터 삭제&lt;/li&gt;
&lt;li&gt;search: list 속에 데이터가 있는지 확인&lt;/li&gt;
&lt;li&gt;getData: N번째 노드의 값을 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;리스트-vs-배열&#34;&gt;리스트 vs 배열&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;항목&lt;/th&gt;
&lt;th&gt;배열&lt;/th&gt;
&lt;th&gt;리스트&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;특정 자료 Read&lt;/td&gt;
&lt;td&gt;쉬움&lt;/td&gt;
&lt;td&gt;어려움&lt;/td&gt;
&lt;td&gt;배열은 index로 특정 자료 불러내기가 용이함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;데이터 크기 변경&lt;/td&gt;
&lt;td&gt;어려움&lt;/td&gt;
&lt;td&gt;쉬움&lt;/td&gt;
&lt;td&gt;배열은 선언 시, 연속된 메모리 공간을 할당함&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;탐색과 정렬을 자주하는 자료형인 경우 -&amp;gt; 배열&lt;/li&gt;
&lt;li&gt;추가/삭제가 많이 일어나는 자료형인 경우 -&amp;gt; 리스트&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linked-List 종류 3가지&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;단순 연결 리스트 (Singly Linked List)
&lt;ul&gt;
&lt;li&gt;다음 노드에 대한 참조만을 가진 가장 단순한 형태의 연결 리스트&lt;/li&gt;
&lt;li&gt;체인이 잘못되 다음 Node를 못찾는 경우, 그 뒤 Node들은 모두 유실&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이중 연결 리스트 (Doubly Linked List)
&lt;ul&gt;
&lt;li&gt;다음 노드, 이전 노드에 대한 참조를 가진 형태의 연결 리스트&lt;/li&gt;
&lt;li&gt;뒤로 Node 탐색 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;순환 연결 리스트 (Circular Linked List)
&lt;ul&gt;
&lt;li&gt;단순 연결 리스트에서 마지막 Node가 Null 대신, 처음 원소를 가리키는 형태&lt;/li&gt;
&lt;li&gt;스트림 버퍼 구현에 많이 사용 되고, 메모리 재사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료의 삽입과 삭제가 용이함&lt;/li&gt;
&lt;li&gt;삽입/삭제 작업 시, 자료의 이동이 불필요함&lt;/li&gt;
&lt;li&gt;자료형 크기를 유동적으로 할당/제거 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;순차적으로 접근해야 해서, 특정 인덱스에 접근하기 까다로움&lt;/li&gt;
&lt;li&gt;포인터 사용으로 인한 메모리 추가 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복잡도&#34;&gt;복잡도&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;삽입: O(1) 또는 O(n) (삽입 위치에 따라)&lt;/li&gt;
&lt;li&gt;삭제: O(1) 또는 O(n) (삭제 위치에 따라)&lt;/li&gt;
&lt;li&gt;검색: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;활용&#34;&gt;활용&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료형의 크기가 정해져 있지 않은 경우&lt;/li&gt;
&lt;li&gt;데이터의 삽입/삭제가 자주 일어나는 경우&lt;/li&gt;
&lt;li&gt;데이터 검색이 자주 일어나지 않는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linked List는 메모리를 효율적으로 활용하면서, 동적으로 크기 조절이 가능한 자료구조이다.
삽입과 삭제가 빈번하게 발생하는 상황에서 유용하게 사용될 수 있다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[자료구조] Queue 개념 정리</title>
        <link>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-queue-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</link>
        <pubDate>Wed, 10 Jan 2024 16:36:53 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-queue-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</guid>
        <description>&lt;h1 id=&#34;queue의-개념&#34;&gt;Queue의 개념&lt;/h1&gt;
&lt;p&gt;자료 구조에서 한 쪽 끝에서 자료가 들어오고, 반대 쪽 끝에서 자료가 나가는 선입 선출 특성의 FIFO (First In First Out) 선형 자료구조&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tteoks.github.io/img/cs_queue.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Queue&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;선입 선출 (FIFO) 구조로 가장 먼저 추가된 데이터가 가장 먼저 제거됨&lt;/li&gt;
&lt;li&gt;스택에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름&lt;/li&gt;
&lt;li&gt;n번째 항목에 직접 접근 할 수 없음&lt;/li&gt;
&lt;li&gt;배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-연산&#34;&gt;주요 연산&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Enqueue 연산: Queue에 데이터를 추가한다.&lt;/li&gt;
&lt;li&gt;Dequeue 연산: Queue에서 데이터를 제거한다.&lt;/li&gt;
&lt;li&gt;Peak 연산: Queue의 맨 앞에 있는 데이터를 조회한다.&lt;/li&gt;
&lt;li&gt;isEmpty 연산: Queue가 비어 있는지 여부를 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료 구조가 단순하여 구현이 쉬움&lt;/li&gt;
&lt;li&gt;데이터 저장/읽기 속도가 빠름&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 최대 개수가 사전에 정의되어야 함&lt;/li&gt;
&lt;li&gt;저장공간 낭비로 이어질 수 있음&lt;/li&gt;
&lt;li&gt;원하는 데이터에 직접 접근하기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복잡도&#34;&gt;복잡도&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;삽입/삭제: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;활용&#34;&gt;활용&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작업 대기열&lt;/li&gt;
&lt;li&gt;네트워크 패킷 처리&lt;/li&gt;
&lt;li&gt;너비 우선 탐색 (BFS)&lt;/li&gt;
&lt;li&gt;캐시 관리&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[자료구조] Stack 개념 정리</title>
        <link>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</link>
        <pubDate>Tue, 09 Jan 2024 11:33:27 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</guid>
        <description>&lt;h1 id=&#34;stack의-개념&#34;&gt;Stack의 개념&lt;/h1&gt;
&lt;p&gt;자료 구조에서 한 쪽 끝에서만 자료를 넣고 빼는 후입선출 특성의 LIFO (Last In First Out) 선형  자료구조j&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tteoks.github.io/img/cs_stack.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Stack&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LIFO (Last In First Out) 구조를 가지고 있음&lt;/li&gt;
&lt;li&gt;가장 최근에 Stack에 추가된 항목이 먼저 제거되어야 함&lt;/li&gt;
&lt;li&gt;Stack에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름&lt;/li&gt;
&lt;li&gt;n번째 항목에 직접 접근 할 수 없음&lt;/li&gt;
&lt;li&gt;배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-연산&#34;&gt;주요 연산&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;pop 연산: Stack에서 가장 위에 있는 항목을 반환 하며, 제거한다.&lt;/li&gt;
&lt;li&gt;push 연산: 자료를 Stack의 가장 윗 부분에 추가한다.&lt;/li&gt;
&lt;li&gt;top 연산: Stack의 가장 위에 있는 항목을 반환한다.&lt;/li&gt;
&lt;li&gt;isEmpty 연산: Stack이 비어있는 경우 true를 반환 / 자료가 존재하는 경우 false를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료 구조가 단순하여 구현이 쉬움&lt;/li&gt;
&lt;li&gt;데이터 저장/읽기 속도가 빠름&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 최대 개수가 사전에 정의되어야 함&lt;/li&gt;
&lt;li&gt;저장공간 낭비로 이어질 수 있음&lt;/li&gt;
&lt;li&gt;원하는 데이터에 직접 접근 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복잡도&#34;&gt;복잡도&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;삽입/삭제: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;활용&#34;&gt;활용&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 브라우저 방문 기록 (뒤로 가기)&lt;/li&gt;
&lt;li&gt;실행 취소 (Undo)&lt;/li&gt;
&lt;li&gt;깊이 우선 탐색 (DFS)&lt;/li&gt;
&lt;li&gt;역순 문자열 만들기&lt;/li&gt;
&lt;li&gt;수식의 괄호 연산 (VPS,Valid Parenthesis String)&lt;/li&gt;
&lt;li&gt;후위 표기법 계산&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>First Post</title>
        <link>https://tteoks.github.io/p/first-post/</link>
        <pubDate>Mon, 08 Jan 2024 17:07:24 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/first-post/</guid>
        <description>&lt;h3 id=&#34;첫-포스팅&#34;&gt;첫 포스팅&lt;/h3&gt;
&lt;p&gt;안녕하세요 블로그 시작을 알리는 글 입니다.&lt;/p&gt;
&lt;p&gt;블로그의 내용은 제가 관심있어하는 기술에 대해서 정리할 예정입니다.&lt;br&gt;
정리되는 내용은 학습한 내용이나, 공유 드릴 만한 정보입니다.&lt;/p&gt;
&lt;h3 id=&#34;기술-블로그-운영-계기&#34;&gt;기술 블로그 운영 계기&lt;/h3&gt;
&lt;p&gt;다양한 이유가 있겠지만, 저의 경우 &lt;strong&gt;공부 내용 백업&lt;/strong&gt; 및 공유가 주된 이유입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어디서든 확인 및 저장할 수 있는 공부 자료 저장소를 운영하고 싶었습니다.&lt;/li&gt;
&lt;li&gt;공개된 공간에 자료를 공개함으로써, 정보에 대해 책임감을 가지고 공부할 수 있지 않을까 싶습니다.&lt;/li&gt;
&lt;li&gt;여러 피드백을 통해 자료의 질을 높이고, 잘못된 정보는 바로 잡으려합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마치며&#34;&gt;마치며&lt;/h3&gt;
&lt;p&gt;계기를 적다보니 이유가 거창해졌는데 원래 시작은 거창하게 하는편입니다.&lt;br&gt;
중요한건 저런 고민을 했다는게 중요하다고 생각합니다.&lt;/p&gt;
&lt;p&gt;피드백 및 소통은 자유지만, 공격적인 태도는 누구에게도 좋을게 없다고 생각합니다.&lt;br&gt;
추후, 너그러운 피드백 부탁드리겠습니다.&lt;/p&gt;
&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>

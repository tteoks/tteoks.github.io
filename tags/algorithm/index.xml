<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Algorithm on Jinho Yu</title>
        <link>https://tteoks.github.io/tags/algorithm/</link>
        <description>Recent content in Algorithm on Jinho Yu</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>COPYRIGHT (C) JINHO,YU. ALL RIGHTS RESERVED.</copyright>
        <lastBuildDate>Sun, 11 Feb 2024 17:15:42 +0900</lastBuildDate><atom:link href="https://tteoks.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[알고리즘] Searching 알고리즘</title>
        <link>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-searching-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
        <pubDate>Sun, 11 Feb 2024 17:15:42 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-searching-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</guid>
        <description>&lt;h1 id=&#34;탐색-알고리즘-common-searching-algorithms&#34;&gt;탐색 알고리즘 (Common Searching Algorithms)&lt;/h1&gt;
&lt;p&gt;탐색 알고리즘은 주어진 데이터 구조에서 구하고자 하는 값이 존재하는지 확인하는 알고리즘이다.&lt;/p&gt;
&lt;p&gt;탐색 알고리즘은 크게 아래 2가지로 구분 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sequenctial Search
&lt;ul&gt;
&lt;li&gt;주어진 배열, 리스트와 같 데이터 구조에서 순차적으로 데이터를 탐색&lt;/li&gt;
&lt;li&gt;대표 알고리즘: Linear Search&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interval Search:
&lt;ul&gt;
&lt;li&gt;정렬된 데이터에서 원하는 데이터를 효율적으로 탐색&lt;/li&gt;
&lt;li&gt;대표 알고리즘: Binary Search&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선형-탐색-알고리즘-linear-search-algorithm&#34;&gt;선형 탐색 알고리즘 (Linear Search Algorithm)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;주어진 리스트에서 원하는 항목을 순차적으로 검색/탐색 하는 간단한 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;주어진 리스트의 각 요소를 처음부터 순차적으로 검색하여 찾고자 하는 항목을 발견할 떄까지 반복&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;리스트 요소들을 하나씩 순차적으로 검색
데이터의 정렬 여부에 관계 없이 사용 가능&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;구현이 간단하고 이해가 쉬움&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;전체 리스트 숱회로 인한 성능 저하&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터가 정렬되어 있지 않은 경우&lt;/li&gt;
&lt;li&gt;탐색 대상이 리스트에 고르게 분포된 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;이진-탐색-알고리즘-binarh-search-algorithm&#34;&gt;이진 탐색 알고리즘 (Binarh Search Algorithm)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;정렬된 리스트에서 특정 항목을 찾는 탐색 알고리즘으로, 리스트를 반으로 나누어 탐색 범위를 줄여나가면서 탐색하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;중앙에 위치한 값을 기준으로 Key보다 작은 값은 왼쪽에서, 큰 값은 오른쪽을 탐색함으로써 중앙값과 key값이 같을 때까지 탐색&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;리스트가 정렬되어야 사용 가능한 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;평균적으로 매우 빠른 탐색 속도를 가짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;데이터가 정렬되어 있어야 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터가 정렬되어 있는 상황에서 데이터를 탐색해야 하는 경우&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[알고리즘] Sort 알고리즘</title>
        <link>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sort-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
        <pubDate>Sun, 11 Feb 2024 14:24:19 +0900</pubDate>
        
        <guid>https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sort-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</guid>
        <description>&lt;h1 id=&#34;정렬&#34;&gt;정렬&lt;/h1&gt;
&lt;p&gt;주어진 데이터를 일정한 순서로 재배열하는 알고리즘으로 이러한 재배열을 통해 검색, 비교, 출력등의 작업을 효율적으로 수행할 수 있음&lt;/p&gt;
&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;인접한 두 원소의 대소를 비교하여 순서가 잘못된 경우, 서로 교환하는 정렬 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열의 처음부터 끝까지 반복하여 인접한 두 원소의 대소를 비교해 정렬을 수행함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구현이 간단하고, 코드 이해가 쉬웁&lt;/li&gt;
&lt;li&gt;소규모 데이터 정렬에 간단하게 사용하기 용이&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;다른 정렬 알고리즘에 비해 비효율적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터가 이미 거의 정렬되어 있는 경우&lt;/li&gt;
&lt;li&gt;정렬할 데이터의 크기가 작을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;삽입-정렬-insert-sort&#34;&gt;삽입 정렬 (Insert Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;두번째 Index부터 시작해 이전 index 원소들과 비교하여 적절한 위치에 삽입하면서 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;크기가 적은 데이터나, 대부분의 데이터가 이미 정렬된 경우 효과적&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;데이터 양이 많거나, 정렬된 상태가 아닐 떄 효율성이 떨어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2) / O(n)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작은 데이터 세트를 정렬할 때 사용&lt;/li&gt;
&lt;li&gt;다른 정렬 알고리즘의 전처리 단계로 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선택-정렬-select-sort&#34;&gt;선택 정렬 (Select Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열에서 최소값(또는 최대값)을 선택하여 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아래 프로세스 반복 (n: {1 ~ n})&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n번째로 작은 데이터를 찾아 n번째 위치와 교환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;비교 횟수가 고정되어 있어, 어떤 데이터가 어떤 순서로 정렬되어 있던 비교횟수가 동일함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 사용 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;불안정 정렬이며, 같은 값의 순서 보장 X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 셋의 크기가 작은 상황에서 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;분할 정복 알고리즘을 기반으로 정렬하는 알고리즘으로, 기준점(pivot)을 기준으로 작은값은 왼쪽, 큰값은 오른쪽에 위치시키며 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pivot을 선택하고, pivot을 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 위치시키며 정렬 수행&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;평균적으로 매우 빠른 속도를 가지며, 분할 과정에서 추가적인 메모리가 필요하지 않음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;매우 효율적으로 정렬을 수행함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;선택된 pivot에 따라 성능이 불규칙함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn) ~ O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(logn)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 상황에서 효율적으로 사용 가능&lt;/li&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;분할 정복 알고리즘을 사용하여 정렬하는 방식으로, 배열을 반으로 나누고 각 부분을 정렬한 후 병합하는 방식으로 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열을 반으로 나누어 정렬된 부분 배열을 만든 후, 병합하여 전체 배열 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;안정적인 정렬 방식이며, 재귀적인 방식으로 구현 가능&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;평균적으로 매우 빠른 속도를 가짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;추가적인 메모리 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;힙(Heap) 자료구조를 이용하여 정렬하는 방식으로, 힙을 구성하고 최대 힙 또느 최소 힙을 유지하면서 졍렬을 수행하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;초기에 배열을 힙으로 구성한 후, 최상단 노드를 삭제하며 정렬 수행&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;완전 이진 트리 구조를 사용하여 효율적으로 수현하며 추가적인 메모리를 사용하지 않음&lt;/p&gt;
&lt;p&gt;최대/최소 힙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대 힙: 부모노드가 항상 자식 노드보다 큼 -&amp;gt; 내림차순 정렬&lt;/li&gt;
&lt;li&gt;최소 힙: 부모노드가 항상 자식 노드보다 작음 -&amp;gt; 오름차순 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;매우 효율적으로 정렬 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;안정적인 정렬 방식이 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬&lt;/li&gt;
&lt;li&gt;우선순위 큐 구현&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;셸-정렬-shell-sort&#34;&gt;셸 정렬 (Shell Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;삽입 정렬을 개선한 알고리즘으로, 배열을 일정한 간격으로 나누어 부분 리스트를 만들고, 각각의 부분 리스트를 삽입 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;일정한 간격(초기값: 전체 배열 길이의 반)을 설정하여 부분 리스트를 생성하고, 해당 부분 리스트를 삽입 정렬을 통해 정렬하며 간격을 줄여가면서 정렬&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;간격에 따라 성능이 크게 달라질 수 있지만, 추가적인 메모리를 사용하지 않음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;평균적으로 삽입 정렬보다 빠름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;최적의 간격을 찾기 어려운 경우도 존재함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(nlogn) ~ O(n^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 데이터 정렬 시, 삽입 정렬보다 빠른 알고리즘이 필요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기수-정렬-radix-sort&#34;&gt;기수 정렬 (Radix Sort)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개념&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자릿수를 기준으로 정렬하는 알고리즘으로 LSD (가장 작은 자리수) 또는 MSD (가장 높은 수) 방식을 통해 정렬하는 알고리즘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동작 방식 (LSD)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;가장 낮은 자리수부터 시작하여 정렬을 수행, 각 자리수별로 정렬
(일의 자리부터 시작해, 가장 높은 자리까지 정렬)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;안정적인 정렬 알고리즘이지만, 데이터 자리수가 큰 경우 공간 복잡도가 커질 수 있음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장/단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;안정적인 정렬 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;일부 자리수가 없는 경우 사용 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복잡도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도: O(d*(n+k)) (d: 최대 자리수, k: 각 자리수 범위)&lt;/li&gt;
&lt;li&gt;공간 복잡도: O(n + k): (k: 각 자리수 볌위)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;활용처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 자리수를 기준으로 정렬 (ex. 정수, 문자열)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;안정-정렬-vs-불안정-정렬&#34;&gt;안정 정렬 vs 불안정 정렬&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;안정 정렬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 값이 입력 순서와 동일하게 정렬되는 알고리즘의 특성&lt;/li&gt;
&lt;li&gt;ex) 삽입 정렬, 벙합 정렬, 버블 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불안정 정렬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중복된 값이 이력 순서와 동일하지 않게 정렬되는 알고리즘의 특성&lt;/li&gt;
&lt;li&gt;ex) 쿽 정렬, 선택 정렬, 계수 정렬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>

[{"content":"연결 리스트 (Linked List) 추상적 자료형인 리스트를 구현한 자료구조로, 데이터 덩어리 (이하 Node)들이 연결된 선형 자료구조이다. 각 노드는 데이터와 다음 노드를 가리키는 링크 (포이터)로 이루어져 있다.\n본 포스팅은 Singly linked list를 기반으로 설명한다.\n특징 연속되는 항목들이 포인터로 연결되어 있음 데이터의 크기 제한이 없음 (데이터 추가/삭제 쉬움) 데이터를 탐색할 때 순차적으로 접근해야 함 메모리를 필요한 만큼만 사용하지만, 포인터로 인한 추가 메모리 필요 주요 함수 add: List 끝에 데이터 삽입 insert: N번째 위치에 데이터삽입 delete: List 끝에 데이터 삭제 search: list 속에 데이터가 있는지 확인 getData: N번째 노드의 값을 반환 리스트 vs 배열 항목 배열 리스트 설명 특정 자료 Read 쉬움 어려움 배열은 index로 특정 자료 불러내기가 용이함 데이터 크기 변경 어려움 쉬움 배열은 선언 시, 연속된 메모리 공간을 할당함 탐색과 정렬을 자주하는 자료형인 경우 -\u0026gt; 배열 추가/삭제가 많이 일어나는 자료형인 경우 -\u0026gt; 리스트 Linked-List 종류 3가지\n단순 연결 리스트 (Singly Linked List) 다음 노드에 대한 참조만을 가진 가장 단순한 형태의 연결 리스트 체인이 잘못되 다음 Node를 못찾는 경우, 그 뒤 Node들은 모두 유실 이중 연결 리스트 (Doubly Linked List) 다음 노드, 이전 노드에 대한 참조를 가진 형태의 연결 리스트 뒤로 Node 탐색 가능 순환 연결 리스트 (Circular Linked List) 단순 연결 리스트에서 마지막 Node가 Null 대신, 처음 원소를 가리키는 형태 스트림 버퍼 구현에 많이 사용 되고, 메모리 재사용 가능 장점 자료의 삽입과 삭제가 용이함 삽입/삭제 작업 시, 자료의 이동이 불필요함 자료형 크기를 유동적으로 할당/제거 가능 단점 순차적으로 접근해야 해서, 특정 인덱스에 접근하기 까다로움 포인터 사용으로 인한 메모리 추가 사용 복잡도 삽입: O(1) 또는 O(n) (삽입 위치에 따라) 삭제: O(1) 또는 O(n) (삭제 위치에 따라) 검색: O(n) 활용 자료형의 크기가 정해져 있지 않은 경우 데이터의 삽입/삭제가 자주 일어나는 경우 데이터 검색이 자주 일어나지 않는 경우 Linked List는 메모리를 효율적으로 활용하면서, 동적으로 크기 조절이 가능한 자료구조이다. 삽입과 삭제가 빈번하게 발생하는 상황에서 유용하게 사용될 수 있다.\n","date":"2024-01-17T14:02:48+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-linked-list-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Linked List 개념 정리"},{"content":"Queue의 개념 자료 구조에서 한 쪽 끝에서 자료가 들어오고, 반대 쪽 끝에서 자료가 나가는 선입 선출 특성의 FIFO (First In First Out) 선형 자료구조\n특징 선입 선출 (FIFO) 구조로 가장 먼저 추가된 데이터가 가장 먼저 제거됨 스택에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름 n번째 항목에 직접 접근 할 수 없음 배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음 주요 연산 Enqueue 연산: Queue에 데이터를 추가한다. Dequeue 연산: Queue에서 데이터를 제거한다. Peak 연산: Queue의 맨 앞에 있는 데이터를 조회한다. isEmpty 연산: Queue가 비어 있는지 여부를 확인한다. 장점 자료 구조가 단순하여 구현이 쉬움 데이터 저장/읽기 속도가 빠름 단점 데이터의 최대 개수가 사전에 정의되어야 함 저장공간 낭비로 이어질 수 있음 원하는 데이터에 직접 접근하기 어려움 복잡도 삽입/삭제: O(1) 활용 작업 대기열 네트워크 패킷 처리 너비 우선 탐색 (BFS) 캐시 관리 ","date":"2024-01-10T16:36:53+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-queue-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Queue 개념 정리"},{"content":"Stack의 개념 자료 구조에서 한 쪽 끝에서만 자료를 넣고 빼는 후입선출 특성의 LIFO (Last In First Out) 선형 자료구조j\n특징 LIFO (Last In First Out) 구조를 가지고 있음 가장 최근에 Stack에 추가된 항목이 먼저 제거되어야 함 Stack에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름 n번째 항목에 직접 접근 할 수 없음 배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음 주요 연산 pop 연산: Stack에서 가장 위에 있는 항목을 반환 하며, 제거한다. push 연산: 자료를 Stack의 가장 윗 부분에 추가한다. top 연산: Stack의 가장 위에 있는 항목을 반환한다. isEmpty 연산: Stack이 비어있는 경우 true를 반환 / 자료가 존재하는 경우 false를 반환한다. 장점 자료 구조가 단순하여 구현이 쉬움 데이터 저장/읽기 속도가 빠름 단점 데이터의 최대 개수가 사전에 정의되어야 함 저장공간 낭비로 이어질 수 있음 원하는 데이터에 직접 접근 어려움 복잡도 삽입/삭제: O(1) 활용 웹 브라우저 방문 기록 (뒤로 가기) 실행 취소 (Undo) 깊이 우선 탐색 (DFS) 역순 문자열 만들기 수식의 괄호 연산 (VPS,Valid Parenthesis String) 후위 표기법 계산 ","date":"2024-01-09T11:33:27+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Stack 개념 정리"},{"content":"첫 포스팅 안녕하세요 블로그 시작을 알리는 글 입니다.\n블로그의 내용은 제가 관심있어하는 기술에 대해서 정리할 예정입니다.\n정리되는 내용은 학습한 내용이나, 공유 드릴 만한 정보입니다.\n기술 블로그 운영 계기 다양한 이유가 있겠지만, 저의 경우 공부 내용 백업 및 공유가 주된 이유입니다.\n어디서든 확인 및 저장할 수 있는 공부 자료 저장소를 운영하고 싶었습니다. 공개된 공간에 자료를 공개함으로써, 정보에 대해 책임감을 가지고 공부할 수 있지 않을까 싶습니다. 여러 피드백을 통해 자료의 질을 높이고, 잘못된 정보는 바로 잡으려합니다. 마치며 계기를 적다보니 이유가 거창해졌는데 원래 시작은 거창하게 하는편입니다.\n중요한건 저런 고민을 했다는게 중요하다고 생각합니다.\n피드백 및 소통은 자유지만, 공격적인 태도는 누구에게도 좋을게 없다고 생각합니다.\n추후, 너그러운 피드백 부탁드리겠습니다.\n감사합니다.\n","date":"2024-01-08T17:07:24+09:00","permalink":"https://tteoks.github.io/p/first-post/","title":"First Post"}]
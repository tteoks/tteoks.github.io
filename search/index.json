[{"content":"탐색 알고리즘 (Common Searching Algorithms) 탐색 알고리즘은 주어진 데이터 구조에서 구하고자 하는 값이 존재하는지 확인하는 알고리즘이다.\n탐색 알고리즘은 크게 아래 2가지로 구분 할 수 있다.\nSequenctial Search 주어진 배열, 리스트와 같 데이터 구조에서 순차적으로 데이터를 탐색 대표 알고리즘: Linear Search Interval Search: 정렬된 데이터에서 원하는 데이터를 효율적으로 탐색 대표 알고리즘: Binary Search 선형 탐색 알고리즘 (Linear Search Algorithm) 개념\n주어진 리스트에서 원하는 항목을 순차적으로 검색/탐색 하는 간단한 알고리즘\n동작 방식\n주어진 리스트의 각 요소를 처음부터 순차적으로 검색하여 찾고자 하는 항목을 발견할 떄까지 반복\n특징\n리스트 요소들을 하나씩 순차적으로 검색 데이터의 정렬 여부에 관계 없이 사용 가능\n장/단점\n장점 구현이 간단하고 이해가 쉬움 단점 전체 리스트 숱회로 인한 성능 저하 복잡도\n시간 복잡도: O(n) 공간 복잡도: O(1) 활용처\n데이터가 정렬되어 있지 않은 경우 탐색 대상이 리스트에 고르게 분포된 경우 이진 탐색 알고리즘 (Binarh Search Algorithm) 개념\n정렬된 리스트에서 특정 항목을 찾는 탐색 알고리즘으로, 리스트를 반으로 나누어 탐색 범위를 줄여나가면서 탐색하는 알고리즘\n동작 방식\n중앙에 위치한 값을 기준으로 Key보다 작은 값은 왼쪽에서, 큰 값은 오른쪽을 탐색함으로써 중앙값과 key값이 같을 때까지 탐색\n특징\n리스트가 정렬되어야 사용 가능한 알고리즘\n장/단점\n장점 평균적으로 매우 빠른 탐색 속도를 가짐 단점 데이터가 정렬되어 있어야 사용 가능 복잡도\n시간 복잡도: O(nlogn) 공간 복잡도: O(1) 활용처\n데이터가 정렬되어 있는 상황에서 데이터를 탐색해야 하는 경우 ","date":"2024-02-11T17:15:42+09:00","permalink":"https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-searching-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"[알고리즘] Searching 알고리즘"},{"content":"정렬 주어진 데이터를 일정한 순서로 재배열하는 알고리즘으로 이러한 재배열을 통해 검색, 비교, 출력등의 작업을 효율적으로 수행할 수 있음\n버블 정렬 (Bubble Sort) 개념\n인접한 두 원소의 대소를 비교하여 순서가 잘못된 경우, 서로 교환하는 정렬 알고리즘\n동작 방식\n배열의 처음부터 끝까지 반복하여 인접한 두 원소의 대소를 비교해 정렬을 수행함\n특징\n구현이 간단하고, 코드 이해가 쉬웁 소규모 데이터 정렬에 간단하게 사용하기 용이 장/단점\n장점 추가적인 메모리 사용 X 단점 다른 정렬 알고리즘에 비해 비효율적 복잡도\n시간 복잡도: O(n^2) 공간 복잡도: O(1) 활용처\n데이터가 이미 거의 정렬되어 있는 경우 정렬할 데이터의 크기가 작을 때 삽입 정렬 (Insert Sort) 개념\n배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘\n동작 방식\n두번째 Index부터 시작해 이전 index 원소들과 비교하여 적절한 위치에 삽입하면서 정렬\n특징\n크기가 적은 데이터나, 대부분의 데이터가 이미 정렬된 경우 효과적\n장/단점\n장점 추가적인 메모리 사용 X 단점 데이터 양이 많거나, 정렬된 상태가 아닐 떄 효율성이 떨어짐 복잡도\n시간 복잡도: O(n^2) / O(n) 공간 복잡도: O(n) 활용처\n작은 데이터 세트를 정렬할 때 사용 다른 정렬 알고리즘의 전처리 단계로 활용 선택 정렬 (Select Sort) 개념\n배열에서 최소값(또는 최대값)을 선택하여 정렬하는 알고리즘\n동작 방식\n아래 프로세스 반복 (n: {1 ~ n})\nn번째로 작은 데이터를 찾아 n번째 위치와 교환 특징\n비교 횟수가 고정되어 있어, 어떤 데이터가 어떤 순서로 정렬되어 있던 비교횟수가 동일함\n장/단점\n장점 추가적인 메모리 사용 X 단점 불안정 정렬이며, 같은 값의 순서 보장 X 복잡도\n시간 복잡도: O(n^2) 공간 복잡도: O(1) 활용처\n데이터 셋의 크기가 작은 상황에서 활용 퀵 정렬 (Quick Sort) 개념\n분할 정복 알고리즘을 기반으로 정렬하는 알고리즘으로, 기준점(pivot)을 기준으로 작은값은 왼쪽, 큰값은 오른쪽에 위치시키며 정렬하는 알고리즘\n동작 방식\npivot을 선택하고, pivot을 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 위치시키며 정렬 수행\n특징\n평균적으로 매우 빠른 속도를 가지며, 분할 과정에서 추가적인 메모리가 필요하지 않음\n장/단점\n장점 매우 효율적으로 정렬을 수행함 단점 선택된 pivot에 따라 성능이 불규칙함 복잡도\n시간 복잡도: O(nlogn) ~ O(n^2) 공간 복잡도: O(logn) 활용처\n대부분의 상황에서 효율적으로 사용 가능 대용량 데이터 정렬 병합 정렬 (Merge Sort) 개념\n분할 정복 알고리즘을 사용하여 정렬하는 방식으로, 배열을 반으로 나누고 각 부분을 정렬한 후 병합하는 방식으로 정렬하는 알고리즘\n동작 방식\n배열을 반으로 나누어 정렬된 부분 배열을 만든 후, 병합하여 전체 배열 정렬\n특징\n안정적인 정렬 방식이며, 재귀적인 방식으로 구현 가능\n장/단점\n장점 평균적으로 매우 빠른 속도를 가짐 단점 추가적인 메모리 필요 복잡도\n시간 복잡도: O(nlogn) 공간 복잡도: O(n) 활용처\n대용량 데이터 정렬 힙 정렬 (Heap Sort) 개념\n힙(Heap) 자료구조를 이용하여 정렬하는 방식으로, 힙을 구성하고 최대 힙 또느 최소 힙을 유지하면서 졍렬을 수행하는 알고리즘\n동작 방식\n초기에 배열을 힙으로 구성한 후, 최상단 노드를 삭제하며 정렬 수행\n특징\n완전 이진 트리 구조를 사용하여 효율적으로 수현하며 추가적인 메모리를 사용하지 않음\n최대/최소 힙\n최대 힙: 부모노드가 항상 자식 노드보다 큼 -\u0026gt; 내림차순 정렬 최소 힙: 부모노드가 항상 자식 노드보다 작음 -\u0026gt; 오름차순 정렬 장/단점\n장점 매우 효율적으로 정렬 수행 단점 안정적인 정렬 방식이 아님 복잡도\n시간 복잡도: O(nlogn) 공간 복잡도: O(n) 활용처\n대용량 데이터 정렬 우선순위 큐 구현 셸 정렬 (Shell Sort) 개념\n삽입 정렬을 개선한 알고리즘으로, 배열을 일정한 간격으로 나누어 부분 리스트를 만들고, 각각의 부분 리스트를 삽입 정렬하는 알고리즘\n동작 방식\n일정한 간격(초기값: 전체 배열 길이의 반)을 설정하여 부분 리스트를 생성하고, 해당 부분 리스트를 삽입 정렬을 통해 정렬하며 간격을 줄여가면서 정렬\n특징\n간격에 따라 성능이 크게 달라질 수 있지만, 추가적인 메모리를 사용하지 않음\n장/단점\n장점 평균적으로 삽입 정렬보다 빠름 단점 최적의 간격을 찾기 어려운 경우도 존재함 복잡도\n시간 복잡도: O(nlogn) ~ O(n^2) 공간 복잡도: O(1) 활용처\n대용량 데이터 정렬 시, 삽입 정렬보다 빠른 알고리즘이 필요한 경우 기수 정렬 (Radix Sort) 개념\n자릿수를 기준으로 정렬하는 알고리즘으로 LSD (가장 작은 자리수) 또는 MSD (가장 높은 수) 방식을 통해 정렬하는 알고리즘\n동작 방식 (LSD)\n가장 낮은 자리수부터 시작하여 정렬을 수행, 각 자리수별로 정렬 (일의 자리부터 시작해, 가장 높은 자리까지 정렬)\n특징\n안정적인 정렬 알고리즘이지만, 데이터 자리수가 큰 경우 공간 복잡도가 커질 수 있음\n장/단점\n장점 안정적인 정렬 방식 단점 일부 자리수가 없는 경우 사용 불가 복잡도\n시간 복잡도: O(d*(n+k)) (d: 최대 자리수, k: 각 자리수 범위) 공간 복잡도: O(n + k): (k: 각 자리수 볌위) 활용처\n특정 자리수를 기준으로 정렬 (ex. 정수, 문자열) 안정 정렬 vs 불안정 정렬 안정 정렬\n중복된 값이 입력 순서와 동일하게 정렬되는 알고리즘의 특성 ex) 삽입 정렬, 벙합 정렬, 버블 정렬 불안정 정렬\n중복된 값이 이력 순서와 동일하지 않게 정렬되는 알고리즘의 특성 ex) 쿽 정렬, 선택 정렬, 계수 정렬 ","date":"2024-02-11T14:24:19+09:00","permalink":"https://tteoks.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sort-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"[알고리즘] Sort 알고리즘"},{"content":"덱 (Deque)의 개념 Deque은 양쪽 끝에서 데이터의 삽입과 삭제가 가능한 선형자료구조로, Double-Ended Queue의 약자이다.\n특징 Deque는 양쪽 끝에서 삽입과 삭제가 이루어질 수 있음 동적으로 자료구조의 크기를 조절 가능 주요 연산 AddFront 연산: Deque의 앞에 데이터를 추가 AddRear 연산: Deque의 뒤에 데이터를 추가 RemoveFront 연산: Deque의 앞의 데이터를 삭제 RemoveRear 연산: Deque의 뒤의 데이터를 삭제 장점 양쪽 끝에서 효율적으로 삽입과 삭제를 O(1)에 수행할 수 있음 Queue와 Stack의 특성을 모두 가지고 있어 다양한 상황에서 활용 가능 단점 배열 기반 구현의 경우, 메모리를 일정하게 할당해야 해서 낭비 발생 가능 양쪽 끝에서 연산을 모두 지원하므로, 구현이 복잡할 수 있음 복잡도 앞/뒤 삽입: O(1) 앞/뒤 삭제: O(1) 활용 스크롤링 목록\n사용자가 스크롤을 하면서 앞과 뒤에서 아이템을 추가하고 삭제할 때 사용 이중 종료 조건의 큐(Queue)\n양쪽에서 삽입과 삭제를 할 수 있는 특성을 이용하여 다양한 큐 구조를 구현 회문(Palindrome) 검사\n앞뒤에서 데이터를 비교하여 회문 여부를 확인할 때 활용 ","date":"2024-01-31T14:23:51+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-deque-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Deque 개념 정리"},{"content":"연결 리스트 (Linked List) 추상적 자료형인 리스트를 구현한 자료구조로, 데이터 덩어리 (이하 Node)들이 연결된 선형 자료구조이다. 각 노드는 데이터와 다음 노드를 가리키는 링크 (포이터)로 이루어져 있다.\n본 포스팅은 Singly linked list를 기반으로 설명한다.\n특징 연속되는 항목들이 포인터로 연결되어 있음 데이터의 크기 제한이 없음 (데이터 추가/삭제 쉬움) 데이터를 탐색할 때 순차적으로 접근해야 함 메모리를 필요한 만큼만 사용하지만, 포인터로 인한 추가 메모리 필요 주요 함수 add: List 끝에 데이터 삽입 insert: N번째 위치에 데이터삽입 delete: List 끝에 데이터 삭제 search: list 속에 데이터가 있는지 확인 getData: N번째 노드의 값을 반환 리스트 vs 배열 항목 배열 리스트 설명 특정 자료 Read 쉬움 어려움 배열은 index로 특정 자료 불러내기가 용이함 데이터 크기 변경 어려움 쉬움 배열은 선언 시, 연속된 메모리 공간을 할당함 탐색과 정렬을 자주하는 자료형인 경우 -\u0026gt; 배열 추가/삭제가 많이 일어나는 자료형인 경우 -\u0026gt; 리스트 Linked-List 종류 3가지\n단순 연결 리스트 (Singly Linked List) 다음 노드에 대한 참조만을 가진 가장 단순한 형태의 연결 리스트 체인이 잘못되 다음 Node를 못찾는 경우, 그 뒤 Node들은 모두 유실 이중 연결 리스트 (Doubly Linked List) 다음 노드, 이전 노드에 대한 참조를 가진 형태의 연결 리스트 뒤로 Node 탐색 가능 순환 연결 리스트 (Circular Linked List) 단순 연결 리스트에서 마지막 Node가 Null 대신, 처음 원소를 가리키는 형태 스트림 버퍼 구현에 많이 사용 되고, 메모리 재사용 가능 장점 자료의 삽입과 삭제가 용이함 삽입/삭제 작업 시, 자료의 이동이 불필요함 자료형 크기를 유동적으로 할당/제거 가능 단점 순차적으로 접근해야 해서, 특정 인덱스에 접근하기 까다로움 포인터 사용으로 인한 메모리 추가 사용 복잡도 삽입: O(1) 또는 O(n) (삽입 위치에 따라) 삭제: O(1) 또는 O(n) (삭제 위치에 따라) 검색: O(n) 활용 자료형의 크기가 정해져 있지 않은 경우 데이터의 삽입/삭제가 자주 일어나는 경우 데이터 검색이 자주 일어나지 않는 경우 Linked List는 메모리를 효율적으로 활용하면서, 동적으로 크기 조절이 가능한 자료구조이다. 삽입과 삭제가 빈번하게 발생하는 상황에서 유용하게 사용될 수 있다.\n","date":"2024-01-17T14:02:48+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-linked-list-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Linked List 개념 정리"},{"content":"Queue의 개념 자료 구조에서 한 쪽 끝에서 자료가 들어오고, 반대 쪽 끝에서 자료가 나가는 선입 선출 특성의 FIFO (First In First Out) 선형 자료구조\n특징 선입 선출 (FIFO) 구조로 가장 먼저 추가된 데이터가 가장 먼저 제거됨 스택에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름 n번째 항목에 직접 접근 할 수 없음 배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음 주요 연산 Enqueue 연산: Queue에 데이터를 추가한다. Dequeue 연산: Queue에서 데이터를 제거한다. Peak 연산: Queue의 맨 앞에 있는 데이터를 조회한다. isEmpty 연산: Queue가 비어 있는지 여부를 확인한다. 장점 자료 구조가 단순하여 구현이 쉬움 데이터 저장/읽기 속도가 빠름 단점 데이터의 최대 개수가 사전에 정의되어야 함 저장공간 낭비로 이어질 수 있음 원하는 데이터에 직접 접근하기 어려움 복잡도 삽입/삭제: O(1) 활용 작업 대기열 네트워크 패킷 처리 너비 우선 탐색 (BFS) 캐시 관리 ","date":"2024-01-10T16:36:53+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-queue-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Queue 개념 정리"},{"content":"Stack의 개념 자료 구조에서 한 쪽 끝에서만 자료를 넣고 빼는 후입선출 특성의 LIFO (Last In First Out) 선형 자료구조j\n특징 LIFO (Last In First Out) 구조를 가지고 있음 가장 최근에 Stack에 추가된 항목이 먼저 제거되어야 함 Stack에서 데이터 추가 및 삭제하는 연산이 다른 자료구조에 비해 빠름 n번째 항목에 직접 접근 할 수 없음 배열처럼 원소들을 하나씩 옆으로 밀어줄 수 없음 주요 연산 pop 연산: Stack에서 가장 위에 있는 항목을 반환 하며, 제거한다. push 연산: 자료를 Stack의 가장 윗 부분에 추가한다. top 연산: Stack의 가장 위에 있는 항목을 반환한다. isEmpty 연산: Stack이 비어있는 경우 true를 반환 / 자료가 존재하는 경우 false를 반환한다. 장점 자료 구조가 단순하여 구현이 쉬움 데이터 저장/읽기 속도가 빠름 단점 데이터의 최대 개수가 사전에 정의되어야 함 저장공간 낭비로 이어질 수 있음 원하는 데이터에 직접 접근 어려움 복잡도 삽입/삭제: O(1) 활용 웹 브라우저 방문 기록 (뒤로 가기) 실행 취소 (Undo) 깊이 우선 탐색 (DFS) 역순 문자열 만들기 수식의 괄호 연산 (VPS,Valid Parenthesis String) 후위 표기법 계산 ","date":"2024-01-09T11:33:27+09:00","permalink":"https://tteoks.github.io/p/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"[자료구조] Stack 개념 정리"},{"content":"첫 포스팅 안녕하세요 블로그 시작을 알리는 글 입니다.\n블로그의 내용은 제가 관심있어하는 기술에 대해서 정리할 예정입니다.\n정리되는 내용은 학습한 내용이나, 공유 드릴 만한 정보입니다.\n기술 블로그 운영 계기 다양한 이유가 있겠지만, 저의 경우 공부 내용 백업 및 공유가 주된 이유입니다.\n어디서든 확인 및 저장할 수 있는 공부 자료 저장소를 운영하고 싶었습니다. 공개된 공간에 자료를 공개함으로써, 정보에 대해 책임감을 가지고 공부할 수 있지 않을까 싶습니다. 여러 피드백을 통해 자료의 질을 높이고, 잘못된 정보는 바로 잡으려합니다. 마치며 계기를 적다보니 이유가 거창해졌는데 원래 시작은 거창하게 하는편입니다.\n중요한건 저런 고민을 했다는게 중요하다고 생각합니다.\n피드백 및 소통은 자유지만, 공격적인 태도는 누구에게도 좋을게 없다고 생각합니다.\n추후, 너그러운 피드백 부탁드리겠습니다.\n감사합니다.\n","date":"2024-01-08T17:07:24+09:00","permalink":"https://tteoks.github.io/p/first-post/","title":"First Post"}]